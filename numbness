local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/drillygzzly/Roblox-UI-Libs/main/1%20Tokyo%20Lib%20(FIXED)/Tokyo%20Lib%20Source.lua"))({
    cheatname = "numbness.cc", -- watermark text
    gamename = "Title Here", -- watermark text
})


local spinSpeed = 10 -- Default speed
_G.Fly = false  -- Default flying status
_G.FlySpeed = 16  -- Default flying speed
_G.SpeedEnabled = false
_G.CharacterSpeed = 16  -- Default speed (WalkSpeed)

--aimbot settings
local aimbotEnabled = false
local healthCheckEnabled = false
local targetPart = "Head"  -- Default target part (could be Head, Torso, etc.)
local aimbotSmoothing = 0.1  -- Smoothing factor for aiming
local aimFovRadius = 150

local espEnabled = false
local updateInterval = 0.01
local lastUpdateTime = 0

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = game.Players.LocalPlayer
local players = game:GetService("Players")
local Camera = game.Workspace.CurrentCamera
local screenWidth = game:GetService("Workspace").CurrentCamera.ViewportSize.X
local screenHeight = game:GetService("Workspace").CurrentCamera.ViewportSize.Y

library:init()

-- Draw the FOV circle
local fovCircle = Drawing.new("Circle")
fovCircle.Radius = aimFovRadius  -- Set the desired radius
fovCircle.Color = Color3.fromRGB(255, 255, 255)  -- Red color for the circle
fovCircle.Thickness = 2
fovCircle.Visible = false  -- Initially invisible, will toggle with the setting

RunService.RenderStepped:Connect(function()
    if fovCircle.Visible then
        -- Get the mouse position relative to the screen
        local mousePos = UserInputService:GetMouseLocation()

        -- Update the FOV circle's position to the mouse position
        fovCircle.Position = Vector2.new(mousePos.X, mousePos.Y)  -- Place circle at mouse position
    end
end)

local Window1  = library.NewWindow({
    title = "numbness.cc | :)", -- Mainwindow Text
    size = UDim2.new(0, 510, 0.6, 6
)})

--tab 1
local Tab1 = Window1:AddTab("  Aimbot  ")
local Tab2 = Window1:AddTab("  Visual  ")
local Tab3 = Window1:AddTab("  Movement  ")
local SettingsTab = library:CreateSettingsTab(Window1)

local Section1 = Tab1:AddSection("Aimbot", 1)

Section1:AddToggle({
    text = "Enable",
    state = false,
    risky = true,
    tooltip = "It's aimbot what do you expect",
    flag = "AimbotToggle",
    risky = false,
    callback = function(v)
        aimbotEnabled = v
    end
}):AddBind({
    enabled = true,
    text = "Aimbotbind",
    tooltip = "tooltip1",
    mode = "hold",
    bind = "None",
    flag = "AimbotBind",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        print(ValueText, v)
    end,
    keycallback = function(v)
        print(ValueText, v)
    end,
    keycallback = function(v)
    end
})

Section1:AddToggle({
    text = "Wall Check",
    state = false,
    risky = true,
    tooltip = "wallcheck",
    flag = "WallCheckToggle",
    risky = false,
    callback = function(v)
        wallCheckEnabled = v
    end
})

Section1:AddToggle({
    text = "Health Check",
    state = false,
    risky = true,
    tooltip = "Health Check",
    flag = "HealthCheckToggle",
    risky = false,
    callback = function(state)
        healthCheckEnabled = state  -- Update the toggle state for health check
        print("Health Check enabled:", healthCheckEnabled)
    end
})

Section1:AddToggle({
    text = "Team Check",
    state = false,
    risky = true,
    tooltip = "teams!",
    flag = "TeamCheckToggle",
    risky = false,
    callback = function(state)
        teamCheckEnabled = state -- Update the global teamCheckEnabled variable
    end
})
Section1:AddSlider({
    enabled = true,
    text = "Smoothness",
    tooltip = "tooltip1",
    flag = "SmoothnessSlider",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0.01,
    max = 1,
    increment = 0.01,
    risky = false,
    callback = function(v)
        aimbotSmoothing = v  -- Smoothness factor is updated based on slider
    end
})

Section1:AddList({
    enabled = true,
    text = "Aim Method", 
    tooltip = "tooltip1",
    selected = "",
    multi = false,
    open = false,
    max = 4,
    values = {"Camera", "Mouse"},
    risky = false,
    callback = function(v)
        print(ValueText, v)
    end
})

Section1:AddList({
    enabled = true,
    text = "Aim Part", 
    tooltip = "tooltip1",
    selected = "Head",
    multi = false,
    open = false,
    max = 4,
    values = {"Head", "HumanoidRootPart", "Torso"},
    risky = false,
    callback = function(v)
        targetPart = v  -- Update the target part based on the selection
        print("Selected target part: " .. targetPart)  -- Debug log to verify the selection
    end
})

--visuals

local Section1 = Tab2:AddSection("ESP", 1)
local Section2 = Tab2:AddSection("FOV Circle", 2)

Section1:AddToggle({
    text = "Box ESP",
    state = false,
    risky = true,
    tooltip = "Boxes",
    flag = "BoxESPToggle",
    risky = false,
    callback = function(v)
        if v then
            EnableBoxESP()
        else
            DisableBoxESP()
        end
    end
})

Section1:AddToggle({
    text = "Health Bar",
    state = false,
    risky = true,
    tooltip = "health",
    flag = "HealthBarToggle",
    risky = false,
    callback = function(v)
        print(ValueText, v)
    end
})

Section1:AddToggle({
    text = "Name ESP",
    state = false,
    risky = true,
    tooltip = "hi",
    flag = "NameESPToggle",
    risky = false,
    callback = function(v)
        if v then
            -- Code to enable Name ESP
            print("Name ESP Enabled")
            EnableNameESP()
        else
            -- Code to disable Name ESP
            print("Name ESP Disabled")
            DisableNameESP()
        end
    end
})

Section1:AddToggle({
    text = "Distance ESP",
    state = false,
    risky = true,
    tooltip = "1 inch pinch",
    flag = "DistanceESPToggle",
    risky = false,
    callback = function(v)
        if v then
            -- Code to enable Distance ESP
            print("Distance ESP Enabled")
            EnableDistanceESP()
        else
            -- Code to disable Distance ESP
            print("Distance ESP Disabled")
            DisableDistanceESP()
        end
    end
})

Section2:AddToggle({
    text = "Show FOV",
    state = false,
    risky = true,
    tooltip = "shows the fov",
    flag = "ShowFOVToggle",
    risky = false,
    callback = function(v)
        fovCircle.Visible = v
    end
})

Section2:AddSlider({
    enabled = true,
    text = "FOV Size",
    tooltip = "tooltip1",
    flag = "AimFovSlider",
    suffix = "",
    dragging = true,
    focused = false,
    min = 50,
    max = 1000,
    increment = 1,
    risky = false,
    callback = function(v)
        aimFovRadius = v  -- Update the FOV radius in real-time
        fovCircle.Radius = aimFovRadius  -- Update the radius of the FOV circle
    end
})

--Movement

local Section1 = Tab3:AddSection("Spinbot", 1)
local Section2 = Tab3:AddSection("Fly", 2)
local Section3 = Tab3:AddSection("Noclip", 1)
local Section4 = Tab3:AddSection("Speed", 2)

Section1:AddToggle({
    text = "Enable Spinbot",
    state = false,
    risky = true,
    tooltip = "spin!!!",
    flag = "SpinBotToggle",
    risky = false,
    callback = function(v)
        if v then
            -- Enable Spinbot functionality
            enableSpinbot()
        else
            -- Disable Spinbot functionality
            disableSpinbot()
        end
    end
})

Section1:AddSlider({
    enabled = true,
    text = "Spinbot Speed",
    tooltip = "tooltip1",
    flag = "SpinbotSlider",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 50,
    increment = 1,
    risky = false,
    callback = function(v)
        spinSpeed = v
        print("Spinbot Speed: " .. spinSpeed)
    end
})

Section2:AddToggle({
    text = "Enable Fly",
    state = false,
    risky = true,
    tooltip = "Fly",
    flag = "FlyToggle",
    risky = false,
    callback = function(v)
        _G.Fly = v
        if v then
            -- When Fly is enabled, ensure platform stand is active
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.PlatformStand = true
            end
        else
            -- When Fly is disabled, reset platform stand
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.PlatformStand = false
            end
        end
    end
})

Section2:AddSlider({
    enabled = true,
    text = "Fly Speed",
    tooltip = "tooltip1",
    flag = "FlySlider",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 500,
    increment = 1,
    risky = false,
    callback = function(v)
        _G.FlySpeed = v  -- Update flying speed
        print("Fly Speed: " .. _G.FlySpeed)
    end
})

Section3:AddToggle({
    text = "Enable Noclip",
    state = false,
    risky = true,
    tooltip = "buggy sometimes but who even uses this",
    flag = "NoClipToggle",
    risky = false,
    callback = function(v)
        if v then
            enableNoclip()  -- Enable Noclip when the toggle is on
        else
            disableNoclip()  -- Disable Noclip when the toggle is off
        end
    end
})

Section4:AddToggle({
    text = "Enable Speed",
    state = false,
    risky = true,
    tooltip = "go fast",
    flag = "SpeedToggle",
    risky = false,
    callback = function(v)
        _G.SpeedEnabled = v
        if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
            if v then
                -- Enable Speed (apply new WalkSpeed)
                LocalPlayer.Character.Humanoid.WalkSpeed = _G.CharacterSpeed
            else
                -- Reset to default WalkSpeed
                LocalPlayer.Character.Humanoid.WalkSpeed = 16
            end
        end
    end
})

Section4:AddSlider({
    enabled = true,
    text = "Speed",
    tooltip = "tooltip1",
    flag = "SpeedSlider",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 500,
    increment = 1,
    risky = false,
    callback = function(v)
        _G.CharacterSpeed = v
        if _G.SpeedEnabled then
            -- Update the WalkSpeed dynamically when Speed is enabled
            if LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid") then
                LocalPlayer.Character.Humanoid.WalkSpeed = _G.CharacterSpeed
            end
        end
        print("Speed set to: " .. _G.CharacterSpeed)
    end
})

local distanceESPObjects = {}  -- Store the Distance ESP objects to update them later
local nameESPObjects = {}  -- Store the Name ESP objects
local boxESPObjects = {}
local widthMultiplier = 0.5 -- Multiplier for the box width

--name esp
function EnableNameESP()
    -- Function to update Name ESP for a given player
    local function updateNameForPlayer(player)
        local character = player.Character
        if character and character:FindFirstChild("Head") then
            local head = character:FindFirstChild("Head")

            -- Create the BillboardGui to display the name
            local billboardGui = Instance.new("BillboardGui")
            billboardGui.Adornee = head
            billboardGui.Parent = head
            billboardGui.Size = UDim2.new(3, 0, 1.5, 0) -- Fixed size, independent of distance
            billboardGui.StudsOffset = Vector3.new(0, 3, 0) -- Position above the player's head
            billboardGui.AlwaysOnTop = true

            -- Create the TextLabel to display the player's name
            local textLabel = Instance.new("TextLabel")
            textLabel.Parent = billboardGui
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.Text = player.Name
            textLabel.TextColor3 = Color3.fromRGB(255, 255, 255) -- White color for text
            textLabel.TextStrokeTransparency = 0.8
            textLabel.TextSize = 14 -- Fixed text size
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.BackgroundTransparency = 1

            -- Store the player's info for continuous updating
            table.insert(nameESPObjects, {
                player = player,
                billboardGui = billboardGui,
                textLabel = textLabel
            })
        end
    end

    -- Update Name ESP for all existing players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            updateNameForPlayer(player)
        end
    end

    -- Listen for new players joining and add Name ESP for them
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            updateNameForPlayer(player)
        end
    end)
end

function DisableNameESP()
    -- Iterate through all stored Name ESP objects and remove their Name ESP
    for _, espObject in pairs(nameESPObjects) do
        if espObject.billboardGui then
            espObject.billboardGui:Destroy() -- Remove the name display
        end
    end
    -- Clear the stored Name ESP objects
    nameESPObjects = {}
end



--distance esp
function EnableDistanceESP()
    -- Function to update distance for a given player
    local function updateDistanceForPlayer(player)
        local character = player.Character
        if character and character:FindFirstChild("Head") then
            local head = character:FindFirstChild("Head")

            -- Create the BillboardGui to display the distance
            local billboardGui = Instance.new("BillboardGui")
            billboardGui.Adornee = head
            billboardGui.Parent = head
            billboardGui.Size = UDim2.new(2, 0, 1, 0) -- Fixed size, independent of distance
            billboardGui.StudsOffset = Vector3.new(0, -5, 0) -- Adjust the display position
            billboardGui.AlwaysOnTop = true

            -- Create the TextLabel to display the distance
            local textLabel = Instance.new("TextLabel")
            textLabel.Parent = billboardGui
            textLabel.Size = UDim2.new(1, 0, 1, 0)
            textLabel.Text = "0.0 studs"
            textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            textLabel.TextStrokeTransparency = 0.8
            textLabel.TextSize = 14 -- Fixed text size
            textLabel.Font = Enum.Font.SourceSansBold
            textLabel.BackgroundTransparency = 1

            -- Store the player's info for continuous updating
            table.insert(distanceESPObjects, {
                player = player,
                billboardGui = billboardGui,
                textLabel = textLabel
            })
        end
    end

    -- Update distance for all existing players
    for _, player in pairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            updateDistanceForPlayer(player)
        end
    end

    -- Start a loop to update the distance every frame
    game:GetService("RunService").RenderStepped:Connect(function()
        for _, espObject in pairs(distanceESPObjects) do
            local player = espObject.player
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                local distance = (game.Players.LocalPlayer.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude
                -- Update the displayed distance in real-time
                espObject.textLabel.Text = string.format("%.1f studs", distance)
            end
        end
    end)

    -- Listen for new players joining and add Distance ESP for them
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            updateDistanceForPlayer(player)
        end
    end)
end

function DisableDistanceESP()
    -- Iterate through all stored Distance ESP objects and remove their Distance ESP
    for _, espObject in pairs(distanceESPObjects) do
        if espObject.billboardGui then
            espObject.billboardGui:Destroy() -- Remove the distance display
        end
    end
    -- Clear the stored Distance ESP objects
    distanceESPObjects = {}
end


--spinbot
local spinbotEnabled = false
local spinConnection
function enableSpinbot()
    if not spinbotEnabled then
        spinbotEnabled = true
        -- Create a connection to spin the character every frame
        spinConnection = game:GetService("RunService").Heartbeat:Connect(function()
            local character = game.Players.LocalPlayer.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                -- Rotate the HumanoidRootPart of the character on the Y-axis
                character.HumanoidRootPart.CFrame = character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
            end
        end)
        print("Spinbot Enabled")
    end
end

-- Function to disable the Spinbot
function disableSpinbot()
    if spinbotEnabled then
        spinbotEnabled = false
        if spinConnection then
            -- Disconnect the heartbeat connection when spinbot is disabled
            spinConnection:Disconnect()
            spinConnection = nil
        end
        print("Spinbot Disabled")
    end
end

--fly
RunService.RenderStepped:Connect(function()
    if _G.Fly and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local Speed = _G.FlySpeed
        local Velocity = Vector3.new(0, 1, 0)  -- Default upwards movement

        -- Movement input handling based on camera direction
        if UserInputService:IsKeyDown(Enum.KeyCode.W) then
            Velocity = Velocity + (Camera.CoordinateFrame.lookVector * Speed)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then
            Velocity = Velocity + (Camera.CoordinateFrame.rightVector * -Speed)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then
            Velocity = Velocity + (Camera.CoordinateFrame.lookVector * -Speed)
        end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then
            Velocity = Velocity + (Camera.CoordinateFrame.rightVector * Speed)
        end

        -- Apply calculated velocity to the character's HumanoidRootPart
        LocalPlayer.Character.HumanoidRootPart.Velocity = Velocity
    end
    task.wait()  -- Small delay to prevent overloading the script
end)

--noclip
function enableNoclip()
    noclipEnabled = true
    if LocalPlayer.Character then
        -- Loop through each part in the character and disable collision
        for _, part in pairs(LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
    print("Noclip Enabled")
end

-- Function to disable Noclip
function disableNoclip()
    noclipEnabled = false
    if LocalPlayer.Character then
        -- Loop through each part in the character and restore collision
        for _, part in pairs(LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = true
            end
        end
    end
    print("Noclip Disabled")
end

-- Function to re-enable Noclip if already enabled after respawn
function reapplyNoclip()
    if noclipEnabled and LocalPlayer.Character then
        -- Loop through each part in the character and disable collision
        for _, part in pairs(LocalPlayer.Character:GetChildren()) do
            if part:IsA("BasePart") then
                part.CanCollide = false
            end
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    reapplyNoclip()
end)

--aimbot
RunService.RenderStepped:Connect(function()
    -- Get the mouse position and update the FOV circle position
    local mousePos = UserInputService:GetMouseLocation()
    fovCircle.Position = mousePos

    -- Check if aimbot is enabled and if the player is holding the right-click (or custom bind)
    if aimbotEnabled and UserInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
        local closestTarget = nil
        local closestScreenDistance = math.huge

        -- Loop through all players and find the closest target within the FOV circle
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild(targetPart) then
                -- **Team Check**: Skip players on the same team if teamCheckEnabled is true
                if teamCheckEnabled and player.Team == LocalPlayer.Team then
                    continue
                end

                local target = player.Character:FindFirstChild(targetPart)

                -- Check health if the health check toggle is enabled
                if healthCheckEnabled then
                    local humanoid = player.Character:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health <= 0 then
                        -- Skip this player if they are dead (health 0) and health check is enabled
                        continue
                    end
                end

                local targetScreenPos, onScreen = Camera:WorldToViewportPoint(target.Position) -- Get the screen position of the target

                -- Calculate the distance from the target's screen position to the mouse position (FOV center)
                if onScreen then
                    local screenDistance = (mousePos - Vector2.new(targetScreenPos.X, targetScreenPos.Y)).Magnitude

                    -- Check if the target is inside the FOV circle and closer to the center
                    if screenDistance <= aimFovRadius and screenDistance < closestScreenDistance then
                        closestScreenDistance = screenDistance
                        closestTarget = target
                    end
                end
            end
        end

        -- If a target is found within the FOV, aim at it
        if closestTarget then
            -- Smooth the aiming by interpolating between current camera CFrame and the target's position
            local targetCFrame = CFrame.new(Camera.CFrame.Position, closestTarget.Position)
            Camera.CFrame = Camera.CFrame:Lerp(targetCFrame, aimbotSmoothing)
        end
    end
end)

--box esp
local function createBoxForCharacter(character, player)
    if not character:FindFirstChild("HumanoidRootPart") then return end

    local box = Drawing.new("Square")
    box.Thickness = 2
    box.Color = Color3.fromRGB(255, 255, 255)
    box.Filled = false
    box.Visible = false

    local espObject = {
        player = player,
        character = character,
        box = box
    }
    table.insert(boxESPObjects, espObject)
end

-- Function to update Box ESPs every `updateInterval`
local function updateBoxESP()
    if not espEnabled then return end  -- Only update ESP if it's enabled

    local currentTime = tick()
    -- Only update every `updateInterval` seconds to avoid constant updates
    if currentTime - lastUpdateTime < updateInterval then return end
    lastUpdateTime = currentTime

    -- Iterate over all ESP objects to update their visibility and positions
    for _, espObject in ipairs(boxESPObjects) do
        local character = espObject.character
        local box = espObject.box

        if character.Parent and character:FindFirstChild("HumanoidRootPart") then
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local head = character:FindFirstChild("Head")
            if rootPart and head then
                local headScreenPos, headOnScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 1.5, 0))
                local footScreenPos, footOnScreen = Camera:WorldToViewportPoint(rootPart.Position + Vector3.new(0, -2.5, 0))

                if headOnScreen and footOnScreen then
                    local height = math.abs(headScreenPos.Y - footScreenPos.Y)
                    local width = height * 0.5
                    box.Position = Vector2.new(headScreenPos.X - width / 2, headScreenPos.Y)
                    box.Size = Vector2.new(width, height)
                    box.Visible = true
                else
                    box.Visible = false
                end
            else
                box.Visible = false
            end
        else
            box.Visible = false
        end
    end
end

-- Function to set up Box ESP for a player
local function setupBoxESP(player)
    if player.Character then
        createBoxForCharacter(player.Character, player)
    end

    player.CharacterAdded:Connect(function(character)
        -- Ensure we remove any old ESP when the player respawns
        for i = #boxESPObjects, 1, -1 do
            if boxESPObjects[i].player == player then
                boxESPObjects[i].box:Remove()  -- Remove previous ESP
                table.remove(boxESPObjects, i)  -- Remove from the list
            end
        end
        createBoxForCharacter(character, player)
    end)
end

-- Clean up Box ESP when players leave
local function cleanupPlayerEvents(player)
    for i = #boxESPObjects, 1, -1 do
        if boxESPObjects[i].player == player then
            boxESPObjects[i].box:Remove()  -- Proper cleanup of the box
            table.remove(boxESPObjects, i)  -- Remove from the list
        end
    end
end

-- Function to enable the ESP
function EnableBoxESP()
    espEnabled = true

    -- Set up ESP for existing players
    for _, player in ipairs(game.Players:GetPlayers()) do
        if player ~= game.Players.LocalPlayer then
            setupBoxESP(player)
        end
    end

    -- Set up ESP for players who join later
    game.Players.PlayerAdded:Connect(function(player)
        if player ~= game.Players.LocalPlayer then
            setupBoxESP(player)
        end
    end)

    -- Remove ESP when a player leaves
    game.Players.PlayerRemoving:Connect(function(player)
        cleanupPlayerEvents(player)
    end)

    -- Use Heartbeat to update ESP periodically
    RunService.Heartbeat:Connect(updateBoxESP)
end

-- Function to disable the ESP
function DisableBoxESP()
    espEnabled = false  -- Disable the ESP updates

    -- Remove all ESP objects and clear the list
    for _, espObject in pairs(boxESPObjects) do
        if espObject.box then
            espObject.box:Remove()
        end
    end
    boxESPObjects = {}
end
